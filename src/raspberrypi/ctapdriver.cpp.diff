*** C:/Users/dmark/Downloads/rascsi147/src/raspberrypi/ctapdriver.cpp	Sat Apr 11 22:51:46 2020
--- C:/Users/dmark/Downloads/rascsi152/src/raspberrypi/netdriver.cpp	Fri Mar 26 21:17:32 2021
***************
*** 1,22 ****
  //---------------------------------------------------------------------------
  //
  //	SCSI Target Emulator RaSCSI (*^..^*)
  //	for Raspberry Pi
- //
  //	Powered by XM6 TypeG Technology.
! //	Copyright (C) 2016-2020 GIMONS
  //
  //	Imported NetBSD support and some optimisation patch by Rin Okuyama.
  //
! //	[ TAPドライバ ]
  //
  //---------------------------------------------------------------------------
  
  #include "os.h"
! #include "xm6.h"
! #include "ctapdriver.h"
  
  //---------------------------------------------------------------------------
  //
  //	コンストラクタ
  //
--- 1,270 ----
  //---------------------------------------------------------------------------
  //
  //	SCSI Target Emulator RaSCSI (*^..^*)
  //	for Raspberry Pi
  //	Powered by XM6 TypeG Technology.
! //
! //	Copyright (C) 2016-2021 GIMONS(Twitter:@kugimoto0715)
  //
  //	Imported NetBSD support and some optimisation patch by Rin Okuyama.
  //
! //	[ ネットワークドライバ ]
  //
  //---------------------------------------------------------------------------
  
  #include "os.h"
! #include "rascsi.h"
! #include "netdriver.h"
! 
! //===========================================================================
! //
! //	ネットワークドライバ
! //
! //===========================================================================
! static NetDriver *self;
! 
! //---------------------------------------------------------------------------
! //
! //	コールバック関数
! //
! //---------------------------------------------------------------------------
! int NetCallback(BOOL read, int func, int phase, int len, BYTE *buf)
! {
! 	ASSERT(self);
! 
! 	return self->Process(read, func, phase, len, buf);
! }
! 
! //---------------------------------------------------------------------------
! //
! //	コンストラクタ
! //
! //---------------------------------------------------------------------------
! NetDriver::NetDriver()
! {
! 	// TAPドライバ生成
! 	tap = new CTapDriver();
! 	m_bTapEnable = tap->Init();
! 
! 	// MACアドレスを生成
! 	memset(mac_addr, 0x00, 6);
! 	if (m_bTapEnable) {
! 		tap->GetMacAddr(mac_addr);
! 		mac_addr[5]++;
! 	}
! 
! 	// パケット受信フラグオフ
! 	packet_enable = FALSE;
! 
! 	// 自身を保存
! 	self = this;
! }
! 
! //---------------------------------------------------------------------------
! //
! //	デストラクタ
! //
! //---------------------------------------------------------------------------
! NetDriver::~NetDriver()
! {
! 	// TAPドライバ解放
! 	if (tap) {
! 		tap->Cleanup();
! 		delete tap;
! 	}
! }
! 
! //---------------------------------------------------------------------------
! //
! //	実行
! //
! //---------------------------------------------------------------------------
! int FASTCALL NetDriver::Process(
! 	BOOL read, int func, int phase, int len, BYTE *buf)
! {
! 	int i;
! 	int total_len;
! 
! 	ASSERT(this);
! 
! 	// TAP無効なら処理しない
! 	if (!m_bTapEnable) {
! 		return 0;
! 	}
! 
! 	if (read) {
! 		switch (func) {
! 			case 0:		// MACアドレス取得
! 				return GetMacAddr(buf);
! 
! 			case 1:		// 受信パケット取得(サイズ/バッファ別)
! 				if (phase == 0) {
! 					// パケットサイズ取得
! 					ReceivePacket();
! 					buf[0] = (BYTE)(packet_len >> 8);
! 					buf[1] = (BYTE)packet_len;
! 					return 2;
! 				} else {
! 					// パケットデータ取得
! 					GetPacketBuf(buf);
! 					return packet_len;
! 				}
! 
! 			case 2:		// 受信パケット取得(サイズ＋バッファ同時)
! 				ReceivePacket();
! 				buf[0] = (BYTE)(packet_len >> 8);
! 				buf[1] = (BYTE)packet_len;
! 				GetPacketBuf(&buf[2]);
! 				return packet_len + 2;
! 
! 			case 3:		// 複数パケット同時取得(サイズ＋バッファ同時)
! 				// パケット数の上限は現状10個に決め打ち
! 				// これ以上増やしてもあまり速くならない?
! 				total_len = 0;
! 				for (i = 0; i < 10; i++) {
! 					ReceivePacket();
! 					*buf++ = (BYTE)(packet_len >> 8);
! 					*buf++ = (BYTE)packet_len;
! 					total_len += 2;
! 					if (packet_len == 0)
! 						break;
! 					GetPacketBuf(buf);
! 					buf += packet_len;
! 					total_len += packet_len;
! 				}
! 				return total_len;
! 		}
! 	} else {
! 		switch (func) {
! 			case 0:		// MACアドレス設定
! 				SetMacAddr(buf);
! 				return len;
! 
! 			case 1:		// パケット送信
! 				SendPacket(buf, len);
! 				return len;
! 		}
! 	}
! 
! 	// エラー
! 	ASSERT(FALSE);
! 	return 0;
! }
! 
! //---------------------------------------------------------------------------
! //
! //	MACアドレス取得
! //
! //---------------------------------------------------------------------------
! int FASTCALL NetDriver::GetMacAddr(BYTE *mac)
! {
! 	ASSERT(this);
! 	ASSERT(mac);
! 
! 	memcpy(mac, mac_addr, 6);
! 	return 6;
! }
! 
! //---------------------------------------------------------------------------
! //
! //	MACアドレス設定
! //
! //---------------------------------------------------------------------------
! void FASTCALL NetDriver::SetMacAddr(BYTE *mac)
! {
! 	ASSERT(this);
! 	ASSERT(mac);
! 
! 	memcpy(mac_addr, mac, 6);
! }
! 
! //---------------------------------------------------------------------------
! //
! //	パケット受信
! //
! //---------------------------------------------------------------------------
! void FASTCALL NetDriver::ReceivePacket()
! {
! 	static const BYTE bcast_addr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
! 
! 	ASSERT(this);
! 	ASSERT(tap);
! 
! 	// 前のパケットが受信されていない
! 	if (packet_enable) {
! 		return;
! 	}
! 
! 	// パケット受信
! 	packet_len = tap->Rx(packet_buf);
! 
! 	// 受信パケットか検査
! 	if (memcmp(packet_buf, mac_addr, 6) != 0) {
! 		if (memcmp(packet_buf, bcast_addr, 6) != 0) {
! 			packet_len = 0;
! 			return;
! 		}
! 	}
! 
! 	// バッファサイズを越えたら捨てる
! 	if (packet_len > 2048) {
! 		packet_len = 0;
! 		return;
! 	}
! 
! 	// 受信バッファに格納
! 	if (packet_len > 0) {
! 		packet_enable = TRUE;
! 	}
! }
! 
! //---------------------------------------------------------------------------
! //
! //	パケット取得
! //
! //---------------------------------------------------------------------------
! void FASTCALL NetDriver::GetPacketBuf(BYTE *buf)
! {
! 	int len;
! 
! 	ASSERT(this);
! 	ASSERT(tap);
! 	ASSERT(buf);
! 
! 	// サイズ制限
! 	len = packet_len;
! 	if (len > 2048) {
! 		len = 2048;
! 	}
! 
! 	// コピー
! 	memcpy(buf, packet_buf, len);
! 
! 	// 受信済み
! 	packet_enable = FALSE;
! }
! 
! //---------------------------------------------------------------------------
! //
! //	パケット送信
! //
! //---------------------------------------------------------------------------
! void FASTCALL NetDriver::SendPacket(BYTE *buf, int len)
! {
! 	ASSERT(this);
! 	ASSERT(tap);
! 	ASSERT(buf);
! 
! 	tap->Tx(buf, len);
! }
! 
! //===========================================================================
! //
! //	TAPドライバ
! //
! //===========================================================================
  
  //---------------------------------------------------------------------------
  //
  //	コンストラクタ
  //
