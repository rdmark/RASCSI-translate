*** src/raspberrypi/rascsi.cpp	Sat Apr 11 22:52:40 2020
--- src/raspberrypi/rascsi.cpp	Sun Mar 28 11:30:26 2021
***************
*** 1,53 ****
  //---------------------------------------------------------------------------
  //
  //	SCSI Target Emulator RaSCSI (*^..^*)
  //	for Raspberry Pi
- //
  //	Powered by XM6 TypeG Technology.
! //	Copyright (C) 2016-2020 GIMONS
  //	[ メイン ]
  //
  //---------------------------------------------------------------------------
  
  #include "os.h"
! #include "xm6.h"
  #include "filepath.h"
  #include "fileio.h"
  #include "disk.h"
  #include "gpiobus.h"
  
  //---------------------------------------------------------------------------
  //
  //	定数宣言
  //
  //---------------------------------------------------------------------------
  #define CtrlMax	8					// Max number of SCSI controllers
! #define UnitNum	2					// Number of units per controller
! #ifdef BAREMETAL
! #define FPRT(fp, ...) printf( __VA_ARGS__ )
! #else
! #define FPRT(fp, ...) fprintf(fp, __VA_ARGS__ )
! #endif	// BAREMETAL
  
  //---------------------------------------------------------------------------
  //
  //	変数宣言
  //
  //---------------------------------------------------------------------------
  static volatile BOOL running;		// 実行中フラグ
  static volatile BOOL active;		// 処理中フラグ
  SASIDEV *ctrl[CtrlMax];				// コントローラ
  Disk *disk[CtrlMax * UnitNum];		// ディスク
  GPIOBUS *bus;						// GPIOバス
  #ifdef BAREMETAL
  FATFS fatfs;						// FatFS
  #else
  int monsocket;						// モニター用ソケット
  pthread_t monthread;				// モニタースレッド
  static void *MonThread(void *param);
  #endif	// BAREMETAL
  
  #ifndef BAREMETAL
  //---------------------------------------------------------------------------
  //
  //	シグナル処理
--- 1,143 ----
  //---------------------------------------------------------------------------
  //
  //	SCSI Target Emulator RaSCSI (*^..^*)
  //	for Raspberry Pi
  //	Powered by XM6 TypeG Technology.
! //
! //	Copyright (C) 2016-2021 GIMONS(Twitter:@kugimoto0715)
! //
  //	[ メイン ]
  //
  //---------------------------------------------------------------------------
  
  #include "os.h"
! #include "rascsi.h"
  #include "filepath.h"
  #include "fileio.h"
  #include "disk.h"
+ #if USE_BRIDGE_NET == 1
+ #include "netdriver.h"
+ #endif	// USE_BRIDGE_NET == 1
+ #if USE_BRIDGE_FS == 1
+ #include "fsdriver.h"
+ #endif	// USE_BRIDGE_FS == 1
  #include "gpiobus.h"
  
  //---------------------------------------------------------------------------
  //
  //	定数宣言
  //
  //---------------------------------------------------------------------------
  #define CtrlMax	8					// Max number of SCSI controllers
! #define UnitNum	2					// Number of units per controller
! 
! //---------------------------------------------------------------------------
! //
! //	Enum definitions
! //
! //---------------------------------------------------------------------------
! enum execprio_e {
! 	PRIO_NORMAL		= 0,		// Normal
! 	PRIO_MIN		= 1,		// Min
! 	PRIO_MAX		= 2			// Max
! };
  
  //---------------------------------------------------------------------------
  //
  //	変数宣言
  //
  //---------------------------------------------------------------------------
  static volatile BOOL running;		// 実行中フラグ
  static volatile BOOL active;		// 処理中フラグ
+ char logbuf[4096];					// Log buffer
  SASIDEV *ctrl[CtrlMax];				// コントローラ
  Disk *disk[CtrlMax * UnitNum];		// ディスク
  GPIOBUS *bus;						// GPIOバス
+ SCSIBR *scsibr;						// Bridge device
  #ifdef BAREMETAL
  FATFS fatfs;						// FatFS
  #else
  int monsocket;						// モニター用ソケット
  pthread_t monthread;				// モニタースレッド
  static void *MonThread(void *param);
  #endif	// BAREMETAL
+ BOOL haltreq;						// HALT request
+ 
+ #if USE_BRIDGE_NET == 1
+ NetDriver *netdrv;					// Network driver
+ #endif	// USE_BRIDGE_NET == 1
+ 
+ #if USE_BRIDGE_FS == 1
+ FsDriver *fsdrv;					// File system driver
+ #endif	// USE_BRIDGE_FS == 1
+ 
+ //---------------------------------------------------------------------------
+ //
+ //	Prototype declarations
+ //
+ //---------------------------------------------------------------------------
+ int CtlCallback(BOOL, int, int, int, BYTE *);
+ int NetCallback(BOOL read, int func, int phase, int len, BYTE *buf);
+ int FsCallback(BOOL read, int func, int phase, int len, BYTE *buf);
+ 
+ //---------------------------------------------------------------------------
+ //
+ //	Fix a thread to a CPU
+ //
+ //---------------------------------------------------------------------------
+ void FixCpu(int cpu)
+ {
+ #ifndef BAREMETAL
+ 	cpu_set_t cpuset;
+ 	int cpus;
+ 
+ 	// Get no. of CPUs
+ 	CPU_ZERO(&cpuset);
+ 	sched_getaffinity(0, sizeof(cpu_set_t), &cpuset);
+ 	cpus = CPU_COUNT(&cpuset);
+ 
+ 	// Set affinity
+ 	if (cpu < cpus) {
+ 		CPU_ZERO(&cpuset);
+ 		CPU_SET(cpu, &cpuset);
+ 		sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);
+ 	}
+ #endif	// !BAREMETAL
+ }
+ 
+ //---------------------------------------------------------------------------
+ //
+ //	Set execution priority
+ //
+ //---------------------------------------------------------------------------
+ void SetExecPrio(execprio_e prio)
+ {
+ #ifndef BAREMETAL
+ 	pthread_t pt;
+ 	struct sched_param schedparam;
+ 
+ 	pt = pthread_self();
+ 
+ 	switch (prio) {
+ 		case PRIO_NORMAL:
+ 			schedparam.sched_priority = 0;
+ 			pthread_setschedparam(pt, SCHED_OTHER, &schedparam);
+ 			break;
+ 
+ 		case PRIO_MIN:
+ 			schedparam.sched_priority = 0;
+ 			pthread_setschedparam(pt, SCHED_IDLE, &schedparam);
+ 			break;
+ 
+ 		case PRIO_MAX:
+ 			schedparam.sched_priority = sched_get_priority_min(SCHED_FIFO);
+ 			pthread_setschedparam(pt, SCHED_FIFO, &schedparam);
+ 			break;
+ 	}
+ #endif	// !BAREMETAL
+ }
  
  #ifndef BAREMETAL
  //---------------------------------------------------------------------------
  //
  //	シグナル処理
***************
*** 60,102 ****
  }
  #endif	// BAREMETAL
  
  //---------------------------------------------------------------------------
  //
  //	バナー出力
  //
  //---------------------------------------------------------------------------
  void Banner(int argc, char* argv[])
  {
! 	FPRT(stdout,"SCSI Target Emulator RaSCSI(*^..^*) ");
! 	FPRT(stdout,"version %01d.%01d%01d(%s, %s)\n",
  		(int)((VERSION >> 8) & 0xf),
  		(int)((VERSION >> 4) & 0xf),
  		(int)((VERSION     ) & 0xf),
  		__DATE__,
  		__TIME__);
! 	FPRT(stdout,"Powered by XM6 TypeG Technology / ");
! 	FPRT(stdout,"Copyright (C) 2016-2020 GIMONS\n");
! 	FPRT(stdout,"Connect type : %s\n", CONNECT_DESC);
  
  	if (argc > 1 && strcmp(argv[1], "-h") == 0) {
! 		FPRT(stdout,"\n");
! 		FPRT(stdout,"Usage: %s [-IDn FILE] ...\n\n", argv[0]);
! 		FPRT(stdout," n is SCSI identification number(0-7).\n");
! 		FPRT(stdout," FILE is disk image file.\n\n");
! 		FPRT(stdout,"Usage: %s [-HDn FILE] ...\n\n", argv[0]);
! 		FPRT(stdout," n is X68000 SASI HD number(0-15).\n");
! 		FPRT(stdout," FILE is disk image file.\n\n");
! 		FPRT(stdout," Image type is detected based on file extension.\n");
! 		FPRT(stdout,"  hdf : SASI HD image(XM6 SASI HD image)\n");
! 		FPRT(stdout,"  hds : SCSI HD image(XM6 SCSI HD image)\n");
! 		FPRT(stdout,"  hdn : SCSI HD image(NEC GENUINE)\n");
! 		FPRT(stdout,"  hdi : SCSI HD image(Anex86 HD image)\n");
! 		FPRT(stdout,"  nhd : SCSI HD image(T98Next HD image)\n");
! 		FPRT(stdout,"  hda : SCSI HD image(APPLE GENUINE)\n");
! 		FPRT(stdout,"  mos : SCSI MO image(XM6 SCSI MO image)\n");
! 		FPRT(stdout,"  iso : SCSI CD image(ISO 9660 image)\n");
  
  #ifndef BAREMETAL
  		exit(0);
  #endif	// BAREMETAL
  	}
--- 150,226 ----
  }
  #endif	// BAREMETAL
  
  //---------------------------------------------------------------------------
  //
+ //	Log output
+ //
+ //---------------------------------------------------------------------------
+ void LogWrite(FILE *fp, const char *format, ...)
+ {
+ 	char buffer[0x200];
+ 	va_list args;
+ 	va_start(args, format);
+ 
+ 	// Format
+ 	vsprintf(buffer, format, args);
+ 
+ 	// End variable length arguments
+ 	va_end(args);
+ 
+ 	// Output logs
+ 	if (!fp) {
+ 		strcat(logbuf, buffer);
+ 	} else {
+ #ifdef BAREMETAL
+ 		printf(buffer);
+ #else
+ 		fprintf(fp, buffer);
+ #endif	// BAREMETAL
+ 	}
+ }
+ 
+ //---------------------------------------------------------------------------
+ //
  //	バナー出力
  //
  //---------------------------------------------------------------------------
  void Banner(int argc, char* argv[])
  {
! 	LogWrite(stdout,"SCSI Target Emulator RaSCSI(*^..^*) ");
! 	LogWrite(stdout,"version %01d.%01d%01d(%s, %s)\n",
  		(int)((VERSION >> 8) & 0xf),
  		(int)((VERSION >> 4) & 0xf),
  		(int)((VERSION     ) & 0xf),
  		__DATE__,
  		__TIME__);
! 	LogWrite(stdout,"Powered by XM6 TypeG Technology / ");
! 	LogWrite(stdout,"Copyright (C) 2016-2021 GIMONS\n");
! #if USE_BURST_BUS == 1 && USE_SYNC_TRANS == 1
! 	LogWrite(stdout,"Synchronous Transfer support\n");
! #endif	// USE_BURST_BUS == 1 && USE_SYNC_TRANS == 1
! 	LogWrite(stdout,"Connect type : %s\n", CONNECT_DESC);
  
  	if (argc > 1 && strcmp(argv[1], "-h") == 0) {
! 		LogWrite(stdout,"\n");
! 		LogWrite(stdout,"Usage: %s [-IDn FILE] ...\n\n", argv[0]);
! 		LogWrite(stdout," n is SCSI identification number(0-7).\n");
! 		LogWrite(stdout," FILE is disk image file.\n\n");
! 		LogWrite(stdout,"Usage: %s [-HDn FILE] ...\n\n", argv[0]);
! 		LogWrite(stdout," n is X68000 SASI HD number(0-15).\n");
! 		LogWrite(stdout," FILE is disk image file.\n\n");
! 		LogWrite(stdout," Image type is detected based on file extension.\n");
! 		LogWrite(stdout,"  hdf : SASI HD image(XM6 SASI HD image)\n");
! 		LogWrite(stdout,"  hds : SCSI HD image(XM6 SCSI HD image)\n");
! 		LogWrite(stdout,"  hdn : SCSI HD image(NEC GENUINE)\n");
! 		LogWrite(stdout,"  hdi : SCSI HD image(Anex86 HD image)\n");
! 		LogWrite(stdout,"  nhd : SCSI HD image(T98Next HD image)\n");
! 		LogWrite(stdout,"  hda : SCSI HD image(APPLE GENUINE)\n");
! 		LogWrite(stdout,"  mos : SCSI MO image(XM6 SCSI MO image)\n");
! 		LogWrite(stdout,"  iso : SCSI CD image(ISO 9660 image)\n\n");
! 		LogWrite(stdout,"Usage: %s CONFIG_FILE\n\n", argv[0]);
! 		LogWrite(stdout," CONFIG_FILE is disk images config file.\n");
  
  #ifndef BAREMETAL
  		exit(0);
  #endif	// BAREMETAL
  	}
***************
*** 108,117 ****
--- 232,253 ----
  //
  //---------------------------------------------------------------------------
  BOOL Init()
  {
  	int i;
+ #ifdef BAREMETAL
+ 	FRESULT fr;
+ #endif	// BAREMETAL
+ 
+ #ifdef BAREMETAL
+ 	// Mount SD card
+ 	fr = f_mount(&fatfs, "", 1);
+ 	if (fr != FR_OK) {
+ 		LogWrite(stderr, "Error : SD card mount failed.\n");
+ 		return FALSE;
+ 	}
+ #endif	// BAREMETAL
  
  #ifndef BAREMETAL
  	struct sockaddr_in server;
  	int yes;
  
***************
*** 130,140 ****
  	}
  
  	// バインド
  	if (bind(monsocket, (struct sockaddr *)&server,
  		sizeof(struct sockaddr_in)) < 0) {
! 		FPRT(stderr, "Error : Already running?\n");
  		return FALSE;
  	}
  
  	// モニタースレッド生成
  	pthread_create(&monthread, NULL, MonThread, NULL);
--- 266,276 ----
  	}
  
  	// バインド
  	if (bind(monsocket, (struct sockaddr *)&server,
  		sizeof(struct sockaddr_in)) < 0) {
! 		LogWrite(stderr, "Error : Already running?\n");
  		return FALSE;
  	}
  
  	// モニタースレッド生成
  	pthread_create(&monthread, NULL, MonThread, NULL);
***************
*** 147,166 ****
--- 283,308 ----
  		return FALSE;
  	}
  	if (signal(SIGTERM, KillHandler) == SIG_ERR) {
  		return FALSE;
  	}
+ 	if (signal(SIGALRM, KillHandler) == SIG_ERR) {
+ 		return FALSE;
+ 	}
  #endif // BAREMETAL
  
  	// GPIOBUS生成
  	bus = new GPIOBUS();
  	
  	// GPIO初期化
  	if (!bus->Init()) {
  		return FALSE;
  	}
  
+ 	// Target mode
+ 	bus->SetMode(GPIOBUS::TARGET);
+ 
  	// バスリセット
  	bus->Reset();
  
  	// コントローラ初期化
  	for (i = 0; i < CtrlMax; i++) {
***************
*** 170,182 ****
--- 312,343 ----
  	// ディスク初期化
  	for (i = 0; i < CtrlMax; i++) {
  		disk[i] = NULL;
  	}
  
+ 	// Host bridge
+ 	scsibr = new SCSIBR();
+ 	scsibr->SetMsgFunc(0, CtlCallback);
+ 
+ #if USE_BRIDGE_NET == 1
+ 	// Network driver
+ 	netdrv = new NetDriver();
+ 	if (netdrv->IsNetEnable()) {
+ 		scsibr->SetMsgFunc(1, NetCallback);
+ 	}
+ #endif	// USE_BRIDGE_NET == 1
+ 
+ #if USE_BRIDGE_FS == 1
+ 	// File system driver
+ 	fsdrv = new FsDriver();
+ 	scsibr->SetMsgFunc(2, FsCallback);
+ #endif	// USE_BRIDGE_FS == 1
+ 
  	// その他
  	running = FALSE;
  	active = FALSE;
+ 	haltreq = FALSE;
  
  	return TRUE;
  }
  
  //---------------------------------------------------------------------------
***************
*** 186,199 ****
  //---------------------------------------------------------------------------
  void Cleanup()
  {
  	int i;
  
  	// ディスク削除
  	for (i = 0; i < CtrlMax * UnitNum; i++) {
  		if (disk[i]) {
! 			delete disk[i];
  			disk[i] = NULL;
  		}
  	}
  
  	// コントローラ削除
--- 347,381 ----
  //---------------------------------------------------------------------------
  void Cleanup()
  {
  	int i;
  
+ #if USE_BRIDGE_NET == 1
+ 	// Delete network driver
+ 	if (netdrv) {
+ 		delete netdrv;
+ 	}
+ #endif	// USE_BRIDGE_NET == 1
+ 
+ #if USE_BRIDGE_FS == 1
+ 	// Delete file system driver
+ 	if (fsdrv) {
+ 		delete fsdrv;
+ 	}
+ #endif	// USE_BRIDGE_FS == 1
+ 
+ 	// Delete bridge device
+ 	if (scsibr) {
+ 		delete scsibr;
+ 	}
+ 
  	// ディスク削除
  	for (i = 0; i < CtrlMax * UnitNum; i++) {
  		if (disk[i]) {
! 			if (disk[i] != scsibr) {
! 				delete disk[i];
! 			}
  			disk[i] = NULL;
  		}
  	}
  
  	// コントローラ削除
***************
*** 266,315 ****
  			continue;
  		}
  
  		// ヘッダー出力
  		if (!find) {
! 			FPRT(fp, "\n");
! 			FPRT(fp, "+----+----+------+-------------------------------------\n");
! 			FPRT(fp, "| ID | UN | TYPE | DEVICE STATUS\n");
! 			FPRT(fp, "+----+----+------+-------------------------------------\n");
  			find = TRUE;
  		}
  
  		// ID,UNIT,タイプ出力
  		type[0] = (char)(pUnit->GetID() >> 24);
  		type[1] = (char)(pUnit->GetID() >> 16);
  		type[2] = (char)(pUnit->GetID() >> 8);
  		type[3] = (char)(pUnit->GetID());
! 		FPRT(fp, "|  %d |  %d | %s | ", id, un, type);
  
  		// マウント状態出力
  		if (pUnit->GetID() == MAKEID('S', 'C', 'B', 'R')) {
! 			FPRT(fp, "%s", "HOST BRIDGE");
  		} else {
  			pUnit->GetPath(filepath);
! 			FPRT(fp, "%s",
  				(pUnit->IsRemovable() && !pUnit->IsReady()) ?
  				"NO MEDIA" : filepath.GetPath());
  		}
  
  		// ライトプロテクト状態出力
  		if (pUnit->IsRemovable() && pUnit->IsReady() && pUnit->IsWriteP()) {
! 			FPRT(fp, "(WRITEPROTECT)");
  		}
  
  		// 次の行へ
! 		FPRT(fp, "\n");
  	}
  
  	// コントローラが無い場合
  	if (!find) {
! 		FPRT(fp, "No device is installed.\n");
  		return;
  	}
  	
! 	FPRT(fp, "+----+----+------+-------------------------------------\n");
  }
  
  //---------------------------------------------------------------------------
  //
  //	コントローラマッピング
--- 448,496 ----
  			continue;
  		}
  
  		// ヘッダー出力
  		if (!find) {
! 			LogWrite(fp, "+----+----+------+-------------------------------------\n");
! 			LogWrite(fp, "| ID | UN | TYPE | DEVICE STATUS\n");
! 			LogWrite(fp, "+----+----+------+-------------------------------------\n");
  			find = TRUE;
  		}
  
  		// ID,UNIT,タイプ出力
  		type[0] = (char)(pUnit->GetID() >> 24);
  		type[1] = (char)(pUnit->GetID() >> 16);
  		type[2] = (char)(pUnit->GetID() >> 8);
  		type[3] = (char)(pUnit->GetID());
! 		LogWrite(fp, "|  %d |  %d | %s | ", id, un, type);
  
  		// マウント状態出力
  		if (pUnit->GetID() == MAKEID('S', 'C', 'B', 'R')) {
! 			LogWrite(fp, "%s", "HOST BRIDGE");
  		} else {
  			pUnit->GetPath(filepath);
! 			LogWrite(fp, "%s",
  				(pUnit->IsRemovable() && !pUnit->IsReady()) ?
  				"NO MEDIA" : filepath.GetPath());
  		}
  
  		// ライトプロテクト状態出力
  		if (pUnit->IsRemovable() && pUnit->IsReady() && pUnit->IsWriteP()) {
! 			LogWrite(fp, "(WRITEPROTECT)");
  		}
  
  		// 次の行へ
! 		LogWrite(fp, "\n");
  	}
  
  	// コントローラが無い場合
  	if (!find) {
! 		LogWrite(fp, "No device is installed.\n");
  		return;
  	}
  	
! 	LogWrite(fp, "+----+----+------+-------------------------------------\n");
  }
  
  //---------------------------------------------------------------------------
  //
  //	コントローラマッピング
***************
*** 334,344 ****
  					if (ctrl[i]) {
  						ctrl[i]->SetUnit(j, NULL);
  					}
  
  					// ユニットを解放
! 					delete disk[unitno];
  				}
  
  				// 新しいユニットの設定
  				disk[unitno] = map[unitno];
  			}
--- 515,527 ----
  					if (ctrl[i]) {
  						ctrl[i]->SetUnit(j, NULL);
  					}
  
  					// ユニットを解放
! 					if (disk[unitno] != scsibr) {
! 						delete disk[unitno];
! 					}
  				}
  
  				// 新しいユニットの設定
  				disk[unitno] = map[unitno];
  			}
***************
*** 372,388 ****
  		// 接続ユニットなし
  		if (sasi_num == 0 && scsi_num == 0) {
  			if (ctrl[i]) {
  				delete ctrl[i];
  				ctrl[i] = NULL;
- 				continue;
  			}
  		}
  
  		// SASI,SCSI混在
  		if (sasi_num > 0 && scsi_num > 0) {
! 			FPRT(fp, "Error : SASI and SCSI can't be mixed\n");
  			continue;
  		}
  
  		if (sasi_num > 0) {
  			// SASIのユニットのみ
--- 555,571 ----
  		// 接続ユニットなし
  		if (sasi_num == 0 && scsi_num == 0) {
  			if (ctrl[i]) {
  				delete ctrl[i];
  				ctrl[i] = NULL;
  			}
+ 			continue;
  		}
  
  		// SASI,SCSI混在
  		if (sasi_num > 0 && scsi_num > 0) {
! 			LogWrite(fp, "Error : SASI and SCSI can't be mixed\n");
  			continue;
  		}
  
  		if (sasi_num > 0) {
  			// SASIのユニットのみ
***************
*** 433,457 ****
  BOOL ProcessCmd(FILE *fp, int id, int un, int cmd, int type, char *file)
  {
  	Disk *map[CtrlMax * UnitNum];
  	int len;
  	char *ext;
  	Filepath filepath;
  	Disk *pUnit;
  
  	// ユニット一覧を複写
  	memcpy(map, disk, sizeof(disk));
  
  	// IDチェック
  	if (id < 0 || id >= CtrlMax) {
! 		FPRT(fp, "Error : Invalid ID\n");
  		return FALSE;
  	}
  
  	// ユニットチェック
  	if (un < 0 || un >= UnitNum) {
! 		FPRT(fp, "Error : Invalid unit number\n");
  		return FALSE;
  	}
  
  	// 接続コマンド
  	if (cmd == 0) {					// ATTACH
--- 616,641 ----
  BOOL ProcessCmd(FILE *fp, int id, int un, int cmd, int type, char *file)
  {
  	Disk *map[CtrlMax * UnitNum];
  	int len;
  	char *ext;
+ 	BOOL filecheck;
  	Filepath filepath;
  	Disk *pUnit;
  
  	// ユニット一覧を複写
  	memcpy(map, disk, sizeof(disk));
  
  	// IDチェック
  	if (id < 0 || id >= CtrlMax) {
! 		LogWrite(fp, "Error : Invalid ID\n");
  		return FALSE;
  	}
  
  	// ユニットチェック
  	if (un < 0 || un >= UnitNum) {
! 		LogWrite(fp, "Error : Invalid unit number\n");
  		return FALSE;
  	}
  
  	// 接続コマンド
  	if (cmd == 0) {					// ATTACH
***************
*** 475,529 ****
  				return FALSE;
  			}
  
  			// 拡張子がSASIタイプで無ければSCSIに差し替え
  			ext = &file[len - 3];
! 			if (xstrcasecmp(ext, "hdf") != 0) {
  				type = 1;
  			}
  		}
  
  		// タイプ別のインスタンスを生成
  		switch (type) {
  			case 0:		// HDF
  				pUnit = new SASIHD();
  				break;
  			case 1:		// HDS/HDN/HDI/NHD/HDA
  				if (ext == NULL) {
  					break;
  				}
! 				if (xstrcasecmp(ext, "hdn") == 0 ||
! 					xstrcasecmp(ext, "hdi") == 0 || xstrcasecmp(ext, "nhd") == 0) {
  					pUnit = new SCSIHD_NEC();
! 				} else if (xstrcasecmp(ext, "hda") == 0) {
  					pUnit = new SCSIHD_APPLE();
  				} else {
  					pUnit = new SCSIHD();
  				}
  				break;
  			case 2:		// MO
  				pUnit = new SCSIMO();
  				break;
  			case 3:		// CD
  				pUnit = new SCSICD();
  				break;
  			case 4:		// BRIDGE
! 				pUnit = new SCSIBR();
  				break;
  			default:
! 				FPRT(fp,	"Error : Invalid device type\n");
  				return FALSE;
  		}
  
! 		// ドライブはファイルの確認を行う
! 		if (type <= 1 || (type <= 3 && xstrcasecmp(file, "-") != 0)) {
  			// パスを設定
  			filepath.SetPath(file);
  
  			// オープン
  			if (!pUnit->Open(filepath)) {
! 				FPRT(fp, "Error : File open error [%s]\n", file);
  				delete pUnit;
  				return FALSE;
  			}
  		}
  
--- 659,724 ----
  				return FALSE;
  			}
  
  			// 拡張子がSASIタイプで無ければSCSIに差し替え
  			ext = &file[len - 3];
! 			if (_xstrcasecmp(ext, "hdf") != 0) {
  				type = 1;
  			}
  		}
  
  		// タイプ別のインスタンスを生成
+ 		filecheck = TRUE;
  		switch (type) {
  			case 0:		// HDF
  				pUnit = new SASIHD();
  				break;
  			case 1:		// HDS/HDN/HDI/NHD/HDA
  				if (ext == NULL) {
  					break;
  				}
! 				if (_xstrcasecmp(ext, "hdn") == 0 ||
! 					_xstrcasecmp(ext, "hdi") == 0 ||
! 					_xstrcasecmp(ext, "nhd") == 0) {
  					pUnit = new SCSIHD_NEC();
! 				} else if (_xstrcasecmp(ext, "hda") == 0) {
  					pUnit = new SCSIHD_APPLE();
  				} else {
  					pUnit = new SCSIHD();
  				}
  				break;
  			case 2:		// MO
  				pUnit = new SCSIMO();
+ 				if (_xstrcasecmp(file, "-") == 0 ||
+ 					_xstrcasecmp(file, "mo") == 0) {
+ 					filecheck = FALSE;
+ 				}
  				break;
  			case 3:		// CD
  				pUnit = new SCSICD();
+ 				if (_xstrcasecmp(file, "-") == 0 ||
+ 					_xstrcasecmp(file, "cd") == 0) {
+ 					filecheck = FALSE;
+ 				}
  				break;
  			case 4:		// BRIDGE
! 				pUnit = scsibr;
! 				filecheck = FALSE;
  				break;
  			default:
! 				LogWrite(fp,	"Error : Invalid device type\n");
  				return FALSE;
  		}
  
! 		// Carry out file check
! 		if (filecheck) {
  			// パスを設定
  			filepath.SetPath(file);
  
  			// オープン
  			if (!pUnit->Open(filepath)) {
! 				LogWrite(fp, "Error : File open error [%s]\n", file);
  				delete pUnit;
  				return FALSE;
  			}
  		}
  
***************
*** 538,561 ****
  		return TRUE;
  	}
  
  	// 有効なコマンドか
  	if (cmd > 4) {
! 		FPRT(fp, "Error : Invalid command\n");
  		return FALSE;
  	}
  
  	// コントローラが存在するか
  	if (ctrl[id] == NULL) {
! 		FPRT(fp, "Error : No such device\n");
  		return FALSE;
  	}
  
  	// ユニットが存在するか
  	pUnit = disk[id * UnitNum + un];
  	if (pUnit == NULL) {
! 		FPRT(fp, "Error : No such device\n");
  		return FALSE;
  	}
  
  	// 切断コマンド
  	if (cmd == 1) {					// DETACH
--- 733,756 ----
  		return TRUE;
  	}
  
  	// 有効なコマンドか
  	if (cmd > 4) {
! 		LogWrite(fp, "Error : Invalid command\n");
  		return FALSE;
  	}
  
  	// コントローラが存在するか
  	if (ctrl[id] == NULL) {
! 		LogWrite(fp, "Error : No such device\n");
  		return FALSE;
  	}
  
  	// ユニットが存在するか
  	pUnit = disk[id * UnitNum + un];
  	if (pUnit == NULL) {
! 		LogWrite(fp, "Error : No such device\n");
  		return FALSE;
  	}
  
  	// 切断コマンド
  	if (cmd == 1) {					// DETACH
***************
*** 568,600 ****
  	}
  
  	// MOかCDの場合だけ有効
  	if (pUnit->GetID() != MAKEID('S', 'C', 'M', 'O') &&
  		pUnit->GetID() != MAKEID('S', 'C', 'C', 'D')) {
! 		FPRT(fp, "Error : Operation denied(Deveice isn't removable)\n");
  		return FALSE;
  	}
  
  	switch (cmd) {
  		case 2:						// INSERT
  			// パスを設定
  			filepath.SetPath(file);
  
  			// オープン
! 			if (pUnit->Open(filepath)) {
! 				FPRT(fp, "Error : File open error [%s]\n", file);
  				return FALSE;
  			}
  			break;
  
  		case 3:						// EJECT
  			pUnit->Eject(TRUE);
  			break;
  
  		case 4:						// PROTECT
  			if (pUnit->GetID() != MAKEID('S', 'C', 'M', 'O')) {
! 				FPRT(fp, "Error : Operation denied(Deveice isn't MO)\n");
  				return FALSE;
  			}
  			pUnit->WriteP(!pUnit->IsWriteP());
  			break;
  		default:
--- 763,795 ----
  	}
  
  	// MOかCDの場合だけ有効
  	if (pUnit->GetID() != MAKEID('S', 'C', 'M', 'O') &&
  		pUnit->GetID() != MAKEID('S', 'C', 'C', 'D')) {
! 		LogWrite(fp, "Error : Operation denied(Deveice isn't removable)\n");
  		return FALSE;
  	}
  
  	switch (cmd) {
  		case 2:						// INSERT
  			// パスを設定
  			filepath.SetPath(file);
  
  			// オープン
! 			if (!pUnit->Open(filepath)) {
! 				LogWrite(fp, "Error : File open error [%s]\n", file);
  				return FALSE;
  			}
  			break;
  
  		case 3:						// EJECT
  			pUnit->Eject(TRUE);
  			break;
  
  		case 4:						// PROTECT
  			if (pUnit->GetID() != MAKEID('S', 'C', 'M', 'O')) {
! 				LogWrite(fp, "Error : Operation denied(Deveice isn't MO)\n");
  				return FALSE;
  			}
  			pUnit->WriteP(!pUnit->IsWriteP());
  			break;
  		default:
***************
*** 605,663 ****
  	return TRUE;
  }
  
  //---------------------------------------------------------------------------
  //
! //	引数処理
  //
  //---------------------------------------------------------------------------
! BOOL ParseArgument(int argc, char* argv[])
  {
- #ifdef BAREMETAL
- 	FRESULT fr;
- 	FIL fp;
- 	char line[512];
- #else
- 	int i;
- #endif	// BAREMETAL
  	int id;
  	int un;
  	int type;
- 	char *argID;
- 	char *argPath;
  	int len;
  	char *ext;
  
! #ifdef BAREMETAL
! 	// SDカードマウント
! 	fr = f_mount(&fatfs, "", 1);
! 	if (fr != FR_OK) {
! 		FPRT(stderr, "Error : SD card mount failed.\n");
  		return FALSE;
  	}
  
! 	// 設定ファイルがなければ処理を中断
! 	fr = f_open(&fp, "rascsi.ini", FA_READ);
! 	if (fr != FR_OK) {
  		return FALSE;
  	}
! #else
  	// IDとパス指定がなければ処理を中断
  	if (argc < 3) {
  		return TRUE;
  	}
  	i = 1;
  	argc--;
- #endif	// BAREMETAL
  
  	// 解読開始
  
  	while (TRUE) {
- #ifdef BAREMETAL
  		// 1行取得
  		memset(line, 0x00, sizeof(line));
! 		if (f_gets(line, sizeof(line) -1, &fp) == NULL) {
  			break;
  		}
  
  		// CR/LF削除
  		len = strlen(line);
--- 800,1009 ----
  	return TRUE;
  }
  
  //---------------------------------------------------------------------------
  //
! //	Parse command
  //
  //---------------------------------------------------------------------------
! BOOL ParseCmd(char *argID, char *argPath)
  {
  	int id;
  	int un;
  	int type;
  	int len;
  	char *ext;
  
! 	if (strlen(argID) == 3 && _xstrncasecmp(argID, "id", 2) == 0) {
! 		// ID or id format
! 
! 		// Check ID no. (0-7)
! 		if (argID[2] < '0' || argID[2] > '7') {
! 			LogWrite(stderr,
! 				"Error : Invalid argument(IDn n=0-7) [%c]\n", argID[2]);
! 			return FALSE;
! 		}
! 
! 		// Set ID, unit
! 		id = argID[2] - '0';
! 		un = 0;
! 	} else if (_xstrncasecmp(argID, "hd", 2) == 0) {
! 		// HD or hd format
! 
! 		if (strlen(argID) == 3) {
! 			// Check HD no. (0-9)
! 			if (argID[2] < '0' || argID[2] > '9') {
! 				LogWrite(stderr,
! 					"Error : Invalid argument(HDn n=0-15) [%c]\n", argID[2]);
! 				return FALSE;
! 			}
! 
! 			// Check ID, unit no.
! 			id = (argID[2] - '0') / UnitNum;
! 			un = (argID[2] - '0') % UnitNum;
! 		} else if (strlen(argID) == 4) {
! 			// Check HD no. (10-15)
! 			if (argID[2] != '1' || argID[3] < '0' || argID[3] > '5') {
! 				LogWrite(stderr,
! 					"Error : Invalid argument(HDn n=0-15) [%c]\n", argID[2]);
! 				return FALSE;
! 			}
! 
! 			// Check ID, unit no.
! 			id = ((argID[3] - '0') + 10) / UnitNum;
! 			un = ((argID[3] - '0') + 10) % UnitNum;
! 		} else {
! 			LogWrite(stderr,
! 				"Error : Invalid argument(IDn or HDn) [%s]\n", argID);
! 			return FALSE;
! 		}
! 	} else {
! 		LogWrite(stderr,
! 			"Error : Invalid argument(IDn or HDn) [%s]\n", argID);
  		return FALSE;
  	}
  
! 	// Skip if there is an active device
! 	if (disk[id * UnitNum + un] &&
! 		!disk[id * UnitNum + un]->IsNULL()) {
! 		return TRUE;
! 	}
! 
! 	// Init device type
! 	type = -1;
! 
! 	// Check ethernet and host bridge
! 	if (_xstrcasecmp(argPath, "bridge") == 0) {
! 		type = 4;
! 	} else if (_xstrcasecmp(argPath, "mo") == 0) {
! 		// Without specifying a file, assume MO
! 		type = 2;
! 	} else if (_xstrcasecmp(argPath, "cd") == 0) {
! 		// Without specifying a file, assume CD
! 		type = 3;
! 	} else {
! 		// Check path length
! 		len = strlen(argPath);
! 		if (len < 5) {
! 			LogWrite(stderr,
! 				"Error : Invalid argument(File path is short) [%s]\n",
! 				argPath);
! 			return FALSE;
! 		}
! 
! 		// Does it have a file extension?
! 		if (argPath[len - 4] != '.') {
! 			LogWrite(stderr,
! 				"Error : Invalid argument(No extension) [%s]\n", argPath);
! 			return FALSE;
! 		}
! 
! 		// Decide a type
! 		ext = &argPath[len - 3];
! 		if (_xstrcasecmp(ext, "hdf") == 0 ||
! 			_xstrcasecmp(ext, "hds") == 0 ||
! 			_xstrcasecmp(ext, "hdn") == 0 ||
! 			_xstrcasecmp(ext, "hdi") == 0 ||
! 			_xstrcasecmp(ext, "nhd") == 0 ||
! 			_xstrcasecmp(ext, "hda") == 0) {
! 			// HD(SASI/SCSI)
! 			type = 0;
! 		} else if (strcasecmp(ext, "mos") == 0) {
! 			// MO
! 			type = 2;
! 		} else if (strcasecmp(ext, "iso") == 0) {
! 			// CD
! 			type = 3;
! 		} else {
! 			// Cannot identify type
! 			LogWrite(stderr,
! 				"Error : Invalid argument(file type) [%s]\n", ext);
! 			return FALSE;
! 		}
! 	}
! 
! 	// Execute command
! 	if (!ProcessCmd(stderr, id, un, 0, type, argPath)) {
  		return FALSE;
  	}
! 
! 	return TRUE;
! }
! 
! //---------------------------------------------------------------------------
! //
! //	Process arguments
! //
! //---------------------------------------------------------------------------
! BOOL ParseArgument(int argc, char* argv[])
! {
! 	int i;
! 	char *argID;
! 	char *argPath;
! 
  	// IDとパス指定がなければ処理を中断
  	if (argc < 3) {
  		return TRUE;
  	}
+ 
+ 	// Skip command name
  	i = 1;
  	argc--;
  
  	// 解読開始
+ 	while (TRUE) {
+ 		if (argc < 2) {
+ 			break;
+ 		}
  
+ 		argc -= 2;
+ 
+ 		// Get ID and path
+ 		argID = argv[i++];
+ 		argPath = argv[i++];
+ 
+ 		// Pre check
+ 		if (argID[0] != '-') {
+ 			LogWrite(stderr,
+ 				"Error : Invalid argument(-IDn or -HDn) [%s]\n", argID);
+ 			break;
+ 		}
+ 		argID++;
+ 
+ 		// Parse command
+ 		ParseCmd(argID, argPath);
+ 	}
+ 
+ 	return TRUE;
+ }
+ 
+ //---------------------------------------------------------------------------
+ //
+ //	Process config file
+ //
+ //---------------------------------------------------------------------------
+ BOOL ParseConfigFile(char *file)
+ {
+ 	Fileio fio;
+ 	char line[512];
+ 	char argID[512];
+ 	char argPath[512];
+ 	int len;
+ 	char *p;
+ 	char *q;
+ 
+ 	// Stop processing if there is no file set
+ 	if (!fio.Open(file, Fileio::ReadOnly)) {
+ 		LogWrite(stdout, "Error : %s is not found.\n", file);
+ 		return FALSE;
+ 	}
+ 
+ 	// Start interpreting
  	while (TRUE) {
  		// 1行取得
  		memset(line, 0x00, sizeof(line));
! 		if (!fio.ReadLine(line, sizeof(line) -1)) {
  			break;
  		}
  
  		// CR/LF削除
  		len = strlen(line);
***************
*** 666,999 ****
  				break;
  			}
  			line[len - 1] = '\0';
  			len--;
  		}
- #else
- 		if (argc < 2) {
- 			break;
- 		}
- 
- 		argc -= 2;
- #endif	// BAREMETAL
- 
- 		// IDとパスを取得
- #ifdef BAREMETAL
- 		argID = &line[0];
- 		argPath = &line[4];
- 		line[3] = '\0';
  
! 		// 事前チェック
! 		if (argID[0] == '\0' || argPath[0] == '\0') {
  			continue;
  		}
- #else
- 		argID = argv[i++];
- 		argPath = argv[i++];
  
! 		// 事前チェック
! 		if (argID[0] != '-') {
! 			FPRT(stderr,
! 				"Error : Invalid argument(-IDn or -HDn) [%s]\n", argID);
! 			goto parse_error;
  		}
- 		argID++;
- #endif	// BAREMETAL
  
! 		if (strlen(argID) == 3 && xstrncasecmp(argID, "id", 2) == 0) {
! 			// ID or idの形式
  
! 			// ID番号をチェック(0-7)
! 			if (argID[2] < '0' || argID[2] > '7') {
! 				FPRT(stderr,
! 					"Error : Invalid argument(IDn n=0-7) [%c]\n", argID[2]);
! 				goto parse_error;
  			}
  
! 			// ID,ユニット確定
! 			id = argID[2] - '0';
! 			un = 0;
! 		} else if (xstrncasecmp(argID, "hd", 2) == 0) {
! 			// HD or hdの形式
! 
! 			if (strlen(argID) == 3) {
! 				// HD番号をチェック(0-9)
! 				if (argID[2] < '0' || argID[2] > '9') {
! 					FPRT(stderr,
! 						"Error : Invalid argument(HDn n=0-15) [%c]\n", argID[2]);
! 					goto parse_error;
! 				}
  
- 				// ID,ユニット確定
- 				id = (argID[2] - '0') / UnitNum;
- 				un = (argID[2] - '0') % UnitNum;
- 			} else if (strlen(argID) == 4) {
- 				// HD番号をチェック(10-15)
- 				if (argID[2] != '1' || argID[3] < '0' || argID[3] > '5') {
- 					FPRT(stderr,
- 						"Error : Invalid argument(HDn n=0-15) [%c]\n", argID[2]);
- 					goto parse_error;
- 				}
  
! 				// ID,ユニット確定
! 				id = ((argID[3] - '0') + 10) / UnitNum;
! 				un = ((argID[3] - '0') + 10) % UnitNum;
! #ifdef BAREMETAL
! 				argPath++;
! #endif	// BAREMETAL
! 			} else {
! 				FPRT(stderr,
! 					"Error : Invalid argument(IDn or HDn) [%s]\n", argID);
! 				goto parse_error;
  			}
! 		} else {
! 			FPRT(stderr,
! 				"Error : Invalid argument(IDn or HDn) [%s]\n", argID);
! 			goto parse_error;
  		}
  
! 		// すでにアクティブなデバイスがあるならスキップ
! 		if (disk[id * UnitNum + un] &&
! 			!disk[id * UnitNum + un]->IsNULL()) {
! 			continue;
  		}
  
! 		// デバイスタイプを初期化
! 		type = -1;
  
! 		// イーサネットとホストブリッジのチェック
! 		if (xstrcasecmp(argPath, "bridge") == 0) {
! 			type = 4;
! 		} else {
! 			// パスの長さをチェック
! 			len = strlen(argPath);
! 			if (len < 5) {
! 				FPRT(stderr,
! 					"Error : Invalid argument(File path is short) [%s]\n",
! 					argPath);
! 				goto parse_error;
! 			}
! 
! 			// 拡張子を持っているか？
! 			if (argPath[len - 4] != '.') {
! 				FPRT(stderr,
! 					"Error : Invalid argument(No extension) [%s]\n", argPath);
! 				goto parse_error;
! 			}
! 
! 			// タイプを決める
! 			ext = &argPath[len - 3];
! 			if (xstrcasecmp(ext, "hdf") == 0 ||
! 				xstrcasecmp(ext, "hds") == 0 ||
! 				xstrcasecmp(ext, "hdn") == 0 ||
! 				xstrcasecmp(ext, "hdi") == 0 || xstrcasecmp(ext, "nhd") == 0 ||
! 				xstrcasecmp(ext, "hda") == 0) {
! 				// HD(SASI/SCSI)
! 				type = 0;
! 			} else if (strcasecmp(ext, "mos") == 0) {
! 				// MO
! 				type = 2;
! 			} else if (strcasecmp(ext, "iso") == 0) {
! 				// CD
! 				type = 3;
! 			} else {
! 				// タイプが判別できない
! 				FPRT(stderr,
! 					"Error : Invalid argument(file type) [%s]\n", ext);
! 				goto parse_error;
! 			}
  		}
  
! 		// コマンド実行
! 		if (!ProcessCmd(stderr, id, un, 0, type, argPath)) {
! 			goto parse_error;
! 		}
  	}
  
- #ifdef BAREMETAL
  	// 設定ファイルクローズ
! 	f_close(&fp);
! #endif	// BAREMETAL
! 
! 	// デバイスリスト表示
! 	ListDevice(stdout);
  
  	return TRUE;
- 
- parse_error:
- 
- #ifdef BAREMETAL
- 	// 設定ファイルクローズ
- 	f_close(&fp);
- #endif	// BAREMETAL
- 
- 	return FALSE;
  }
  
- #ifndef BAREMETAL
  //---------------------------------------------------------------------------
  //
! //	Bind thread to a single CPU
  //
  //---------------------------------------------------------------------------
! void FixCpu(int cpu)
  {
! 	cpu_set_t cpuset;
! 	int cpus;
  
! 	// Get no. of CPUs
! 	CPU_ZERO(&cpuset);
! 	sched_getaffinity(0, sizeof(cpu_set_t), &cpuset);
! 	cpus = CPU_COUNT(&cpuset);
  
! 	// Set affinity
! 	if (cpu < cpus) {
! 		CPU_ZERO(&cpuset);
! 		CPU_SET(cpu, &cpuset);
! 		sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);
  	}
  }
  
  //---------------------------------------------------------------------------
  //
  //	モニタースレッド
  //
  //---------------------------------------------------------------------------
  static void *MonThread(void *param)
  {
- 	struct sched_param schedparam;
  	struct sockaddr_in client;
  	socklen_t len; 
  	int fd;
  	FILE *fp;
  	char buf[BUFSIZ];
! 	char *p;
! 	int i;
! 	char *argv[5];
! 	int id;
! 	int un;
! 	int cmd;
! 	int type;
! 	char *file;
! 
! 	// Set scheduler
! 	schedparam.sched_priority = 0;
! 	sched_setscheduler(0, SCHED_IDLE, &schedparam);
  
  	// CPUを固定
  	FixCpu(2);
  
  	// 実行開始待ち
  	while (!running) {
  		usleep(1);
  	}
  
  	// 監視準備
  	listen(monsocket, 1);
  
! 	while (1) {
  		// 接続待ち
  		memset(&client, 0, sizeof(client)); 
  		len = sizeof(client); 
  		fd = accept(monsocket, (struct sockaddr*)&client, &len);
  		if (fd < 0) {
  			break;
  		}
  
! 		// Get command
  		fp = fdopen(fd, "r+");
! 		p = fgets(buf, BUFSIZ, fp);
  
! 		// Failed to get command
! 		if (!p) {
! 			goto next;
! 		}
! 
! 		// Delete newline char
! 		p[strlen(p) - 1] = 0;
  
! 		// Display device list
! 		if (xstrncasecmp(p, "list", 4) == 0) {
! 			ListDevice(fp);
! 			goto next;
  		}
  
! 		// Separate parameters
! 		argv[0] = p;
! 		for (i = 1; i < 5; i++) {
! 			// Skip parameter value
! 			while (*p && (*p != ' ')) {
! 				p++;
! 			}
  
! 			// Replace space by NULL
! 			while (*p && (*p == ' ')) {
! 				*p++ = 0;
! 			}
  
! 			// Lost the parameter
! 			if (!*p) {
! 				break;
! 			}
  
! 			// Identify as parameter
! 			argv[i] = p;
! 		}
  
! 		// Failed to get all parameters
! 		if (i < 5) {
! 			goto next;
  		}
  
! 		// ID, unit, command, type, file
! 		id = atoi(argv[0]);
! 		un = atoi(argv[1]);
! 		cmd = atoi(argv[2]);
! 		type = atoi(argv[3]);
! 		file = argv[4];
  
! 		// Wait until idle
! 		while (active) {
! 			usleep(500 * 1000);
! 		}
  
! 		// Execute command
! 		ProcessCmd(fp, id, un, cmd, type, file);
  
! next:
! 		// Release connection
! 		fclose(fp);
! 		close(fd);
  	}
- 
- 	return NULL;
  }
- #endif	// BAREMETAL
  
  //---------------------------------------------------------------------------
  //
  //	主処理
  //
  //---------------------------------------------------------------------------
  #ifdef BAREMETAL
  extern "C"
  int startrascsi(void)
  {
! 	int argc = 0;
! 	char** argv = NULL;
  #else
  int main(int argc, char* argv[])
  {
  #endif	// BAREMETAL
  	int i;
  	int ret;
  	int actid;
  	DWORD now;
  	BUS::phase_t phase;
  	BYTE data;
! #ifndef BAREMETAL
! 	struct sched_param schparam;
  #endif	// BAREMETAL
  
  	// バナー出力
  	Banner(argc, argv);
  
--- 1012,1309 ----
  				break;
  			}
  			line[len - 1] = '\0';
  			len--;
  		}
  
! 		// Skip blank lines
! 		if (line[0] == '\0') {
  			continue;
  		}
  
! 		// Scan chars until blankspace and tab
! 		p = line;
! 		while (p[0]) {
! 			if (p[0] != ' ' && p[0] != '\t') {
! 				break;
! 			}
! 			p++;
  		}
  
! 		// Skip comment lines
! 		if (p[0] == '#') {
! 			continue;
! 		}
  
! 		// Scan until blankspace and tab
! 		q = p;
! 		while (q[0]) {
! 			if (q[0] == ' ' || q[0] == '\t') {
! 				break;
  			}
+ 			q++;
+ 		}
  
! 		// Define ID
! 		memcpy(argID, p, (q - p));
! 		argID[(q - p)] = '\0';
  
  
! 		// Scan chars until blankspace and tab
! 		p = q;
! 		while (p[0]) {
! 			if (p[0] != ' ' && p[0] != '\t') {
! 				break;
  			}
! 			p++;
  		}
  
! 		// Scan until blankspace and tab
! 		q = p;
! 		while (q[0]) {
! 			if (q[0] == ' ' || q[0] == '\t') {
! 				break;
! 			}
! 			q++;
  		}
  
! 		// Define path
! 		memcpy(argPath, p, (q - p));
! 		argPath[(q - p)] = '\0';
  
! 		// Pre check
! 		if (argID[0] == '\0' || argPath[0] == '\0') {
! 			continue;
  		}
  
! 		// Parse commands
! 		ParseCmd(argID, argPath);
  	}
  
  	// 設定ファイルクローズ
! 	fio.Close();
  
  	return TRUE;
  }
  
  //---------------------------------------------------------------------------
  //
! //	Process control commands
  //
  //---------------------------------------------------------------------------
! void ParseCtrCmd(FILE *fp, char *line)
  {
! 	int i;
! 	char *p;
! 	char *argv[5];
! 	int id;
! 	int un;
! 	int cmd;
! 	int type;
! 	char *file;
  
! 	// If the target of the output is the buffer, then clear
! 	if (!fp) {
! 		logbuf[0] = '\0';
! 	}
  
! 	// Get parameters
! 	p = line;
! 
! 	// Delete new line chars
! 	p[strlen(p) - 1] = 0;
! 
! 	// Trigger shutdown (after 3s)
! 	if (_xstrncasecmp(p, "shutdown", 8) == 0) {
! 		haltreq = TRUE;
! #ifdef BAREMETAL
! 		running = FALSE;
! #else
! 		alarm(3);
! #endif	// BAREMETAL
! 		return;
! 	}
! 
! 	// Trigger server shutdown (after 3s)
! 	if (_xstrncasecmp(p, "stop", 4) == 0) {
! #ifdef BAREMETAL
! 		running = FALSE;
! #else
! 		alarm(3);
! #endif	// BAREMETAL
! 		return;
! 	}
! 
! 	// Display device list
! 	if (_xstrncasecmp(p, "list", 4) == 0) {
! 		ListDevice(fp);
! 		return;
! 	}
! 
! 	// Split parameters
! 	argv[0] = p;
! 	for (i = 1; i < 5; i++) {
! 		// Skip parameter value
! 		while (*p && (*p != ' ')) {
! 			p++;
! 		}
! 
! 		// Replace space by NULL
! 		while (*p && (*p == ' ')) {
! 			*p++ = 0;
! 		}
! 
! 		// Lost track of parameters
! 		if (!*p) {
! 			break;
! 		}
! 
! 		// Identify as parameter
! 		argv[i] = p;
  	}
+ 
+ 	// Failed to get all parameters
+ 	if (i < 5) {
+ 		delete[] p;
+ 		return;
+ 	}
+ 
+ 	// ID, unit, command, type, file
+ 	id = atoi(argv[0]);
+ 	un = atoi(argv[1]);
+ 	cmd = atoi(argv[2]);
+ 	type = atoi(argv[3]);
+ 	file = argv[4];
+ 
+ 	// Execute command
+ 	ProcessCmd(fp, id, un, cmd, type, file);
  }
  
+ #ifndef BAREMETAL
  //---------------------------------------------------------------------------
  //
  //	モニタースレッド
  //
  //---------------------------------------------------------------------------
  static void *MonThread(void *param)
  {
  	struct sockaddr_in client;
  	socklen_t len; 
  	int fd;
  	FILE *fp;
  	char buf[BUFSIZ];
! 	char *line;
  
  	// CPUを固定
  	FixCpu(2);
  
+ 	// Execution priority
+ 	SetExecPrio(PRIO_MIN);
+ 
  	// 実行開始待ち
  	while (!running) {
  		usleep(1);
  	}
  
  	// 監視準備
  	listen(monsocket, 1);
  
! 	while (running) {
  		// 接続待ち
  		memset(&client, 0, sizeof(client)); 
  		len = sizeof(client); 
  		fd = accept(monsocket, (struct sockaddr*)&client, &len);
  		if (fd < 0) {
  			break;
  		}
  
! 		// Get commandline
  		fp = fdopen(fd, "r+");
! 		line = fgets(buf, BUFSIZ, fp);
  
! 		if (line) {
! 			// Wait until idle
! 			while (active) {
! 				usleep(500 * 1000);
! 			}
  
! 			// Process command line
! 			ParseCtrCmd(fp, line);
  		}
  
! 		// Release connection
! 		fclose(fp);
! 		close(fd);
! 	}
  
! 	return NULL;
! }
! #endif	// !BAREMETAL
  
! //---------------------------------------------------------------------------
! //
! //	Controller callback function
! //
! //---------------------------------------------------------------------------
! int CtlCallback(BOOL read, int func, int phase, int len, BYTE *buf)
! {
! 	int msglen;
! 	char line[BUFSIZ];
  
! 	if (read) {
! 		// The bridge is requesting data
  
! 		// Clear response data
! 		memset(buf, 0x00, len);
! 
! 		// Transfer log
! 		msglen = strlen(logbuf);
! 		if (msglen > len) {
! 			msglen = len;
  		}
+ 		memcpy(buf, logbuf, msglen);
  
! 		return len;
! 	} else {
! 		// The bridge is requesting processing of data
  
! 		// Get command line
! 		strcpy(line, (char*)buf);
  
! 		// Process command line
! 		ParseCtrCmd(NULL, line);
  
! 		return len;
  	}
  }
  
  //---------------------------------------------------------------------------
  //
  //	主処理
  //
  //---------------------------------------------------------------------------
  #ifdef BAREMETAL
  extern "C"
  int startrascsi(void)
  {
! 	int argc = 2;
! 	char *argv[2];
  #else
  int main(int argc, char* argv[])
  {
  #endif	// BAREMETAL
  	int i;
  	int ret;
  	int actid;
  	DWORD now;
  	BUS::phase_t phase;
  	BYTE data;
! 
! #ifdef BAREMETAL
! 	// Hard code settings file
! 	argv[0] = (char *)"rascsi";
! 	argv[1] = (char *)"rascsi.ini";
  #endif	// BAREMETAL
  
  	// バナー出力
  	Banner(argc, argv);
  
***************
*** 1002,1071 ****
  	if (!Init()) {
  		ret = EPERM;
  		goto init_exit;
  	}
  
! 	// リセット
! 	Reset();
  
- #ifdef BAREMETAL
  	// BUSYアサート(ホスト側を待たせるため)
  	bus->SetBSY(TRUE);
- #endif
  
  	// 引数処理
! 	if (!ParseArgument(argc, argv)) {
! 		ret = EINVAL;
! 		goto err_exit;
  	}
  
! #ifdef BAREMETAL
  	// BUSYネゲート(ホスト側を待たせるため)
  	bus->SetBSY(FALSE);
- #endif
  
! #ifndef BAREMETAL
  	// CPUを固定
  	FixCpu(3);
  
! #ifdef USE_SEL_EVENT_ENABLE
! 	// スケジューリングポリシー設定(最優先)
! 	schparam.sched_priority = sched_get_priority_max(SCHED_FIFO);
! 	sched_setscheduler(0, SCHED_FIFO, &schparam);
! #endif	// USE_SEL_EVENT_ENABLE
! #endif	// BAREMETAL
  
  	// 実行開始
  	running = TRUE;
  
  	// メインループ
  	while (running) {
  		// ワーク初期化
  		actid = -1;
  		phase = BUS::busfree;
  
- #ifdef USE_SEL_EVENT_ENABLE
  		// SEL信号ポーリング
! 		if (bus->PollSelectEvent() < 0) {
! 			// 割り込みで停止
! 			if (errno == EINTR) {
! 				break;
! 			}
  			continue;
  		}
  
  		// バスの状態取得
  		bus->Aquire();
! #else
! 		bus->Aquire();
  		if (!bus->GetSEL()) {
- #if !defined(BAREMETAL)
- 			usleep(0);
- #endif	// !BAREMETAL
  			continue;
  		}
- #endif	// USE_SEL_EVENT_ENABLE
  
  		// イニシエータがID設定中にアサートしている
  		// 可能性があるのでBSYが解除されるまで待つ(最大3秒)
  		if (bus->GetBSY()) {
  			now = SysTimer::GetTimerLow();
--- 1312,1386 ----
  	if (!Init()) {
  		ret = EPERM;
  		goto init_exit;
  	}
  
! 	// Bus reset
! 	bus->Reset();
  
  	// BUSYアサート(ホスト側を待たせるため)
  	bus->SetBSY(TRUE);
  
  	// 引数処理
! 	if (argc == 2) {
! 		if (!ParseConfigFile(argv[1])) {
! 			ret = EINVAL;
! 			goto err_exit;
! 		}
! 	} else {
! 		if (!ParseArgument(argc, argv)) {
! 			ret = EINVAL;
! 			goto err_exit;
! 		}
  	}
  
! 	// Display device list
! 	ListDevice(stdout);
! 
  	// BUSYネゲート(ホスト側を待たせるため)
  	bus->SetBSY(FALSE);
  
! 	// Reset controllers and bus
! 	Reset();
! 
  	// CPUを固定
  	FixCpu(3);
  
! 	// Execution priority
! 	SetExecPrio(PRIO_MAX);
  
  	// 実行開始
  	running = TRUE;
  
  	// メインループ
  	while (running) {
  		// ワーク初期化
  		actid = -1;
  		phase = BUS::busfree;
  
  		// SEL信号ポーリング
! 		ret = bus->PollSelectEvent();
! 		if (ret < 0) {
  			continue;
  		}
  
  		// バスの状態取得
  		bus->Aquire();
! 
! 		// Notify bus reset
! 		if (bus->GetRST()) {
! 			for (i = 0; i < CtrlMax; i++) {
! 				if (ctrl[i]) {
! 					ctrl[i]->Reset();
! 				}
! 			}
! 		}
! 
! 		// Halt if not SELECT
  		if (!bus->GetSEL()) {
  			continue;
  		}
  
  		// イニシエータがID設定中にアサートしている
  		// 可能性があるのでBSYが解除されるまで待つ(最大3秒)
  		if (bus->GetBSY()) {
  			now = SysTimer::GetTimerLow();
***************
*** 1075,1085 ****
  					break;
  				}
  			}
  		}
  
! 		// ビジー、または他のデバイスが応答したので止める
  		if (bus->GetBSY() || !bus->GetSEL()) {
  			continue;
  		}
  
  		// 全コントローラに通知
--- 1390,1400 ----
  					break;
  				}
  			}
  		}
  
! 		// Stop, because busy or another device has responded
  		if (bus->GetBSY() || !bus->GetSEL()) {
  			continue;
  		}
  
  		// 全コントローラに通知
***************
*** 1106,1121 ****
  		}
  
  		// ターゲット走行開始
  		active = TRUE;
  
- #if !defined(USE_SEL_EVENT_ENABLE) && !defined(BAREMETAL)
- 		// スケジューリングポリシー設定(最優先)
- 		schparam.sched_priority = sched_get_priority_max(SCHED_FIFO);
- 		sched_setscheduler(0, SCHED_FIFO, &schparam);
- #endif	// !USE_SEL_EVENT_ENABLE && !BAREMETAL
- 
  		// バスフリーになるまでループ
  		while (running) {
  			// ターゲット駆動
  			phase = ctrl[actid]->Process();
  
--- 1421,1430 ----
***************
*** 1123,1148 ****
  			if (phase == BUS::busfree) {
  				break;
  			}
  		}
  
- #if !defined(USE_SEL_EVENT_ENABLE) && !defined(BAREMETAL)
- 		// スケジューリングポリシー設定(ノーマル)
- 		schparam.sched_priority = 0;
- 		sched_setscheduler(0, SCHED_OTHER, &schparam);
- #endif	// !USE_SEL_EVENT_ENABLE && !BAREMETAL
- 
  		// ターゲット走行終了
  		active = FALSE;
  	}
  
  err_exit:
  	// クリーンアップ
  	Cleanup();
  
  init_exit:
  #if !defined(BAREMETAL)
  	exit(ret);
  #else
  	return ret;
  #endif	// BAREMETAL
  }
--- 1432,1454 ----
  			if (phase == BUS::busfree) {
  				break;
  			}
  		}
  
  		// ターゲット走行終了
  		active = FALSE;
  	}
  
  err_exit:
  	// クリーンアップ
  	Cleanup();
  
  init_exit:
  #if !defined(BAREMETAL)
+ 	if (haltreq) {
+ 		system("halt");
+ 	}
  	exit(ret);
  #else
  	return ret;
  #endif	// BAREMETAL
  }